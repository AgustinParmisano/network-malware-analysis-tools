import sys
import os
import subprocess
import pprint
import time
import pandas as pd
from datetime import datetime
from bat import bro_log_reader
from bat.log_to_dataframe import LogToDataFrame
from pyod.models.pca import PCA

# TODO s: 
# - Seach and resolve others TODO s in whole code.
# - Analyze if internal and network IPs can be read from another file (like README.md or come conf) or can be hardcoded as 192.168.X.X
# - Create a label hiarerchy class like: father label class with name, characteristics and points, then label childrens for levels and customs.
# - Clean code (prints, wrong comments, main, help, params, hardcoded variables)

# Bro-Dataframe Rows Format:
# [0] uid                    CXvywd555Le9IImG9
# [1] id.orig_h                  192.168.1.197
# [2] id.orig_p                          51656
# [3] id.resp_h                 185.244.25.108
# [4] id.resp_p                             80
# [5] proto                                tcp
# [6] service                             http
# [7] duration          0 days 00:00:01.954395
# [8] orig_bytes                            86
# [9] resp_bytes                         51041
# [10] conn_state                            SF
# [11] local_orig                           NaN
# [12] local_resp                           NaN
# [13] missed_bytes                           0
# [14] history                        ShADadtfF
# [15] orig_pkts                             80
# [16] orig_ip_bytes                       5492
# [17] resp_pkts                             78
# [18] resp_ip_bytes                     106154
# [19] tunnel_parents                   (empty)
# [20] MultiLabel                          None

pwd = os.popen('pwd').read()[:-1]
csvfile = str(pwd) + "/labeled_dataframe_assigner.csv"
logfile = str(pwd) + "/labeled_dataframe_assigner.log"
date = os.popen('date').read()[:-1]
errorlog =  "No errors."
success = ""

# Level Labeling Function
# 1st Level (direction): From, To.
# 2nd Level (host): Background, Bening, InfectedDevice.
# 3rd Level (Transport Layer Protocol): UDP, TCP.
# 4th Level (Connection State): Established, Attempts. 
# 5th Level (Application Layer Protocol): HTTP, DNS, FTP, Telnet, SSH, HTTP/TLS
# 6th Level (Encoded/Encrypted): BinaryProtocol (this is for encrypted), Encoded, ASCII (or empty), Encrypted (you should be sure)
# 7th Level (Extra Comments): Upload, Download, FileDownload, HTTP-Ad, SPAM,  Proxy, CC, DDoS, HeartBeat, ConnectivityCheck. (can be empty) 
def level_labeling(dataframe_row):
    row = dataframe_row
    labeled_row1 = first_level_labeling(row)
    labeled_row2 = second_level_labeling(labeled_row1)
    labeled_row3 = third_level_labeling(labeled_row2)
    labeled_row4 = fourth_level_labeling(labeled_row3)
    labeled_row5 = fifth_level_labeling(labeled_row4)
    labeled_row6 = sixth_level_labeling(labeled_row5)
    return labeled_row6

# 1st Level (direction): From, To.
def first_level_labeling(dataframe_row):
    #print("first_level_labeling")
    row = dataframe_row
    # Getting the network and host IP from Bro log
    readed_ip = row[1][1]
    network_third_octet_ip = "" 
    internal_network = "192.168." + str(network_third_octet_ip)
    if internal_network in readed_ip:
        ip = ""
        ip = ip.join(readed_ip.split(".")[2:-1])
        ip += ip.join(".")
        ip += ip.join(readed_ip.split(".")[3:])
        host_last_octet_ip = ip
    else:
        host_last_octet_ip = "0.1"
    internal_ip = str(internal_network) + str(host_last_octet_ip)
    
    # From InfectedDevice
    # [1] id.orig_h must be -> internal
    # [3] id.resp_h must be -> external
    if (row[1][1] == internal_ip) and (row[1][3] != internal_network):
        row[1][int(columns)] += ", FromInfectedDevice"
        row[1][int(columns)+1] += "-FromInfectedDevice"

    # To InfectedDevice
    # [1] id.orig_h must be -> external
    # [3] id.resp_h must be -> internal
    if (row[1][3] == internal_ip) and row[1][3] (row[1][1] != internal_network):
        row[1][int(columns)] += ", ToInfectedDevice"
        row[1][int(columns)+1] += "- ToInfectedDevice"

    return row

# 2nd Level (host): Background, Bening, InfectedDevice.
def second_level_labeling(dataframe_row):
    #print("second_level_labeling")
    #TODO: Analyze hot to detect background, normal, botnet and InfectedDevice traffic flow. For example: normal comes from normal captures, InfectedDevice comes from lvl 1 but background and botnet (???)
    row = dataframe_row
    return row

# 3rd Level (Transport Layer Protocol): UDP, TCP.
def third_level_labeling(dataframe_row):
    #print("third_level_labeling")
    # Could be removed to avoid information redundancy
    # [5] proto tcp/udp
    row = dataframe_row
    if (row[1][5] == "tcp"):
        row[1][int(columns)] += ", TCP"
        row[1][int(columns)+1] += "-TCP"
    
    if (row[1][5] == "udp"):
        row[1][int(columns)] += ", UDP"
        row[1][int(columns)+1] += "-UDP"
   
    return row

# 4th Level (Connection State): Established, Attempts. 
def fourth_level_labeling(dataframe_row):
    #print("fourth_level_labeling")
    # TODO: Analyze how to label this states maybe with conn_state (see what the letters means)
    # [10] conn_state   SF
    # TODO: Analyze how to label this states maybe with duration, talk with Frenky and Pau
    # [7] duration  0 days 00:00:01.954395
    row = dataframe_row
    try:
        if str(row[1][7]) != "NaT":
            time_row = str(row[1][7]).split("days")[1].strip()
            date_struct = datetime.strptime(str(time_row), '%H:%M:%S.%f')
            ms = date_struct.microsecond
        
            # 500000 Microseconds = half second
            if (ms > 500000):
                row[1][int(columns)] += ", DurationHalfSec"
                row[1][int(columns)+1] += "-DurationHalfSec" 
        else:
            row[1][int(columns)] += ", NoDurationInfo"
            row[1][int(columns)+1] += "-NoDurationInfo"
    except:
        print(str(row[1]))
        print(str(row[1][7]))
        time.sleep(5)

    return row

# 5th Level (Application Layer Protocol): HTTP, DNS, FTP, Telnet, SSH, HTTP/TLS, IRC
def fifth_level_labeling(dataframe_row):
    #print("fifth_level_labeling")
    # [6] service   http
    row = dataframe_row
    if (row[1][6] == "http"):
        #print("FOUND HTTP")
        row[1][int(columns)] += ", HTTP"
        row[1][int(columns)+1] += "-HTTP"
    
    row = dataframe_row
    if (row[1][6] == "ssh"):
        #print("FOUND SSH")
        row[1][int(columns)] += ", SSH"
        row[1][int(columns)+1] += "-SSH"

    row = dataframe_row
    if (row[1][6] == "irc"):
        #print("FOUND IRC")
        row[1][int(columns)] += ", IRC"
        row[1][int(columns)+1] += "-IRC"

    row = dataframe_row
    if (row[1][6] == "telnet"):
        #print("FOUND TELNET")
        row[1][int(columns)] += ", Telnet"
        row[1][int(columns)+1] += "-Telnet"

    row = dataframe_row
    if (row[1][6] == "dns"):
        #print("FOUND DNS")
        row[1][int(columns)] += ", DNS"
        row[1][int(columns)+1] += "-DNS"
    
    row = dataframe_row
    if (row[1][6] == "ftp"):
        #print("FOUND FTP")
        row[1][int(columns)] += ", FTP"
        row[1][int(columns)+1] += "-FTP"

    # TODO: check how bro detects HTTP/TLS
    row = dataframe_row
    if (row[1][6] == "tls"):
        #print("FOUND HTTP/TLS")
        row[1][int(columns)] += ", HTTP/TLS"
        row[1][int(columns)+1] += "-HTTP/TLS"

    return row

# TODO: The hard level
# 6th Level (Encoded/Encrypted): BinaryProtocol (this is for encrypted), Encoded, ASCII (or empty), Encrypted (you should be sure)
def sixth_level_labeling(dataframe_row):
    #print("sixth_level_labeling")
    print("dataframe_row")
    print(dataframe_row)
    
    #BIG PAYLOAD PROBLEM!!!!!!!!!!! HOW TO GET PAYLOAD FROM BRO FLOWS???????????????????

    # TODO: BinaryProtocol
    # Problem: How to read and be sure its a binary protocol?
    # Possible solution: Send the payload to the hexa decode tool and if it returns legible ASCII its not binary protocol.
    # Problem: How to know a string its legible or not automatically?
    # Possible solution: Search for some python tool???

    # TODO: Encoded
    # Problem: How to read and be sure its a encoded payload?
    # Possible solution: Send the payload to the hexa decode tool and if it returns legible ASCII its an encoded protocol.
    
    # TODO: ASCII
    # Problem: How to read and be sure its a ASCII payload?
    # Problem: How to know a string its legible or not automatically?
    # Possible solution: Search for some python tool???

    # TODO: Encrypted (WARNING!! We should be sure!! or Empty)
    # Problem: how to be sure its encrypted? the encryption posibilities are beyond automations!?
    # Possible solution: Send the payload to CiberChef magic function and see if it decodes something?

    return row


# 7th Level (Extra Comments): Upload, Download, FileDownload, HTTP-Ad, SPAM, Proxy, CC, DDoS, HeartBeat, ConnectivityCheck. (can be empty) 
def seventh_level_labeling(dataframe_row):
    #print("seventh_level_labeling")
    # Extra Comments
    
    # By payload
    # [18] resp_ip_bytes    106154
    row = dataframe_row
    if (float(row[1][18]) > 150000): # Testing number
        row[1][int(columns)] += ", BigPayload"
        row[1][int(columns)+1] += "-BigPayload"


    #TODO: Upload

    #TODO: Download

    #TODO: FileDownload

    #TODO: HTTP-Ad

    #TODO: SPAM

    #TODO: Proxy

    #TODO: CC

    #TODO: DDoS

    #TODO: HeartBeat

    #TODO: ConnectivityCheck

    return row


# Custom Labeling Function (testing purposes)
def custom_labeling(dataframe_row):
    #print("custom_labeling")
    row = dataframe_row
    labeled_row = port_labeling(row)
    labeled_row = service_labeling(labeled_row)
    labeled_row = payload_labeling(labeled_row)
    return labeled_row

def port_labeling(dataframe_row):
    #print("port_labeling")
    row = dataframe_row
    
    # Known Mirai Port 4441
    if row[1][4] == 4441:
        row[1][int(columns)] += ", MiraiPort, MaliciousPort, RiskHigh"
        row[1][int(columns)+1] = "MaliciousPort"
    
    # Known Mirai Port 23
    if row[1][4] == 23:
        row[1][int(columns)] += ", MiraiPort, PossibleMaliciousPort, RiskMedium"
        row[1][int(columns)+1] = "PossibleMaliciousPort"
    
    # Known Mirai Port 2323
    if row[1][4] == 2323:
        row[1][int(columns)] += ", MiraiPort, MaliciousPort, RiskHigh"
        row[1][int(columns)+1] = "MaliciousPort"    
    
    # Known Router Attack Mirai Variant Port 53413
    if row[1][4] == 53413:
        row[1][int(columns)] += ", MiraiPort, MaliciousPort, RouterAttack RiskHigh"
        row[1][int(columns)+1] = "MaliciousPort"    
    
    # Known Router Attack Satori (Mirai Variant) Port 37215
    if row[1][4] == 37215:
        row[1][int(columns)] += ", Satori, MiraiPort, MaliciousPort, RouterAttack RiskHigh"
        row[1][int(columns)+1] = "MaliciousPort"    

    # Known Router Attack Satori (Mirai Variant) Port 52869
    if row[1][4] == 52869:
        row[1][int(columns)] += ", Satori, MiraiPort, MaliciousPort, RouterAttack RiskHigh"
        row[1][int(columns)+1] = "MaliciousPort"  

    # Known Steam Attack Okane (Mirai Variant) Port 27015
    if row[1][4] == 27015:
        row[1][int(columns)] += ", Okane, MiraiPort, MaliciousPort, RouterAttack RiskHigh"
        row[1][int(columns)+1] = "MaliciousPort"  

    # Known Comera Attack Mirai Variant Port 81
    if row[1][4] == 81:
        row[1][int(columns)] += ", MiraiPort, MaliciousPort, CameraAttack RiskHigh"
        row[1][int(columns)+1] = "MaliciousPort"  
    
    return row

def service_labeling(dataframe_row):
    #print("service_labeling")
    row = dataframe_row

    # SSH Service (need to know how to distinguish from LAN and WAN SSH connections and directions)
    if str(row[1][6]) == "ssh":
        row[1][int(columns)] += ", SSHExternal, MaliciousService, RiskHigh"
        row[1][int(columns)+1] = "MaliciousService" 

    # DNS Service (testing purposes)
    if str(row[1][6]) == "dns":
        row[1][int(columns)] += ", DNSQuery"
        row[1][int(columns)+1] = "DNSQuery" 

    # IRC Service
    if str(row[1][6]) == "IRC":
        row[1][int(columns)] += ", IRCChannel, MaliciousService, RiskHigh"
        row[1][int(columns)+1] = "MaliciousService" 

    # Telnet Service
    if str(row[1][6]) == "Telnet":
        row[1][int(columns)] += ", TelnetControl, MaliciousService, RiskHigh"
        row[1][int(columns)+1] = "MaliciousService" 

    return row

def payload_labeling(dataframe_row):
    #print("payload_labeling")
    row = dataframe_row

    # Big payload data
    if str(row[1][9]) != "nan":
        if int(row[1][9]) > 100:
            row[1][int(columns)] += ", BigPayload, SuspiciousActivity, RiskLow"
            row[1][int(columns)+1] = "BigPayload"  

    # No payload data
    if str(row[1][9]) != "nan":
        if int(row[1][9]) < 1:
            row[1][int(columns)] += ", NoPayload"
            row[1][int(columns)+1] = "NoPayload" 

    # TODO: See how to retrieve payload data and get the hexadecimal to compare with known malicious hexa codes.

    return row

if __name__ == '__main__':
    pp = pprint.PrettyPrinter(indent=4)
    new_list = []

    brologfile = sys.argv[1]
    print('Analizing Bro File: ', str(brologfile))
    print("Results at: " + str(csvfile))
    print("Logs at: " + str(logfile))
    
    # Create a Pandas dataframe from a Bro log
    log_to_df = LogToDataFrame()
    bro_df = log_to_df.create_dataframe(brologfile)
    
    # Insert new labels columns at the end
    columns=len(bro_df.columns)
    bro_df.insert(int(columns), "MultiLabel", "", True) 
    bro_df.insert(int(columns)+1, "UniLabel", "", True) 
    
    # Loop the generated dataframe rows to search for key analysis patterns (such as known malicious ports)
    iterrows = bro_df.iterrows()    

    try:
        for row in iterrows:
            labeled_row = custom_labeling(row)
            labeled_row = level_labeling(labeled_row)
            new_list.append(labeled_row[1])

        new_df = pd.DataFrame(new_list, columns = list(bro_df.columns))
        new_df.to_csv(csvfile)
        sucess="Results written in " + str(csvfile)

    except Exception as e:
        errorlog = str(e)
        sucess = "Error has ocurred."
        raise(e)


log_file= open(str(logfile),"a+")
log_file.write("----- Logs from last execution of labeled_dataframe_assigner.py -----\n")
log_file.write("Date: " + str(date) + "\n")
log_file.write("Errors: " + str(errorlog) + "\n")
log_file.write("Sucess: " + str(sucess) + "\n")
log_file.write("---------- Logs Ends ----------\n")
